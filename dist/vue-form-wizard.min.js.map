{"version":3,"file":null,"sources":["../src/components/FormWizard.js","../src/components/TabContent.js","../src/index.js"],"sourcesContent":["export default{\n  props: {\n    title: {\n      type: String,\n      default: 'Awesome Wizard'\n    },\n    subtitle: {\n      type: String,\n      default: 'Split a complicated flow in multiple steps'\n    },\n    nextButtonText: {\n      type: String,\n      default: 'Next'\n    },\n    backButtonText: {\n      type: String,\n      default: 'Back'\n    },\n    finishButtonText: {\n      type: String,\n      default: 'Finish'\n    },\n    hideButtons: {\n      type: Boolean,\n      default: false\n    },\n    validateOnBack: Boolean,\n    /***\n     * Applies to text, border and circle\n     */\n    color: {\n      type: String,\n      default: '#e74c3c'\n    },\n    errorColor: {\n      type: String,\n      default: '#8b0000'\n    },\n    shape: {\n      type: String,\n      default: 'circle'\n    },\n    /**\n     * Name of the transition when transition between steps\n     * */\n    transition: {\n      type: String,\n      default: ''\n    },\n    /***\n     *\n     * Index of the initial tab to display\n     */\n    startIndex: {\n      type: Number,\n      default: 0,\n      validator: (value) => {\n        return value >= 0\n      }\n    }\n  },\n  data () {\n    return {\n      activeTabIndex: 0,\n      isLastStep: false,\n      currentPercentage: 0,\n      maxStep: 0,\n      loading: false,\n      tabs: []\n    }\n  },\n  computed: {\n    tabCount () {\n      return this.tabs.length\n    },\n    displayPrevButton () {\n      return this.activeTabIndex !== 0\n    },\n    stepPercentage () {\n      return 1 / (this.tabCount * 2) * 100\n    },\n    progressBarStyle () {\n      return {\n        backgroundColor: this.color,\n        width: `${this.progress}%`,\n        color: this.color\n      }\n    },\n    iconActiveStyle () {\n      return {\n        backgroundColor: this.color\n      }\n    },\n    stepCheckedStyle () {\n      return {\n        borderColor: this.color\n      }\n    },\n    errorStyle () {\n      return {\n        borderColor: this.errorColor,\n        backgroundColor: this.errorColor\n      }\n    },\n    stepTitleStyle () {\n      var isError = this.tabs[this.activeTabIndex].validationError\n      return {\n        color: isError ? this.errorColor : this.color\n      }\n    },\n    isStepSquare () {\n      return this.shape === 'square'\n    },\n    isTabShape () {\n      return this.shape === 'tab'\n    },\n    fillButtonStyle () {\n      return {\n        backgroundColor: this.color,\n        borderColor: this.color,\n        color: 'white'\n      }\n    },\n    progress () {\n      let percentage = 0\n      if (this.activeTabIndex > 0) {\n        let stepsToAdd = 1\n        let stepMultiplier = 2\n        percentage = this.stepPercentage * ((this.activeTabIndex * stepMultiplier) + stepsToAdd)\n      } else {\n        percentage = this.stepPercentage\n      }\n      return percentage\n    }\n  },\n  methods: {\n    isChecked (index) {\n      return index <= this.maxStep\n    },\n    navigateToTab (index) {\n      let validate = index > this.activeTabIndex\n      if (index <= this.maxStep) {\n        let cb = () => {\n          this.changeTab(this.activeTabIndex, index)\n        }\n        if (validate) {\n          this.beforeTabChange(this.activeTabIndex, cb)\n        } else {\n          this.setValidationError(null)\n          cb()\n        }\n      }\n    },\n    nextTab () {\n      let cb = () => {\n        if (this.activeTabIndex < this.tabCount - 1) {\n          this.changeTab(this.activeTabIndex, this.activeTabIndex + 1)\n        } else {\n          this.isLastStep = true\n          this.$emit('finished')\n        }\n      }\n      this.beforeTabChange(this.activeTabIndex, cb)\n    },\n    prevTab () {\n      let cb = () => {\n        if (this.activeTabIndex > 0) {\n          this.setValidationError(null)\n          this.changeTab(this.activeTabIndex, this.activeTabIndex - 1)\n          this.isLastStep = false\n        }\n      }\n      if (this.validateOnBack) {\n        this.beforeTabChange(this.activeTabIndex, cb)\n      } else {\n        cb()\n      }\n    },\n    finish () {\n      let cb = () => {\n        this.$emit('on-complete')\n      }\n      this.beforeTabChange(this.activeTabIndex, cb)\n    },\n    setLoading (value) {\n      this.loading = value\n      this.$emit('on-loading', value)\n    },\n    setValidationError (error) {\n      this.tabs[this.activeTabIndex].validationError = error\n      this.$emit('on-error', error)\n    },\n    validateBeforeChange (promiseFn, callback) {\n      this.setValidationError(null)\n      // we have a promise\n      if (promiseFn.then && typeof promiseFn.then === 'function') {\n        this.setLoading(true)\n        promiseFn.then((res) => {\n          this.setLoading(false)\n          let validationResult = res === true\n          this.executeBeforeChange(validationResult, callback)\n        }).catch((error) => {\n          this.setLoading(false)\n          this.setValidationError(error)\n        })\n        // we have a simple function\n      } else {\n        let validationResult = promiseFn === true\n        this.executeBeforeChange(validationResult, callback)\n      }\n    },\n    executeBeforeChange (validationResult, callback) {\n      this.$emit('on-validate', validationResult, this.activeTabIndex)\n      if (validationResult) {\n        callback()\n      } else {\n        this.tabs[this.activeTabIndex].validationError = 'error'\n      }\n    },\n    beforeTabChange (index, callback) {\n      if (this.loading) {\n        return\n      }\n      let oldTab = this.tabs[index]\n      if (oldTab && oldTab.beforeChange !== undefined) {\n        let tabChangeRes = oldTab.beforeChange()\n        this.validateBeforeChange(tabChangeRes, callback)\n      } else {\n        callback()\n      }\n    },\n    changeTab (oldIndex, newIndex) {\n      let oldTab = this.tabs[oldIndex]\n      let newTab = this.tabs[newIndex]\n      if (oldTab) {\n        oldTab.active = false\n      }\n      if (newTab) {\n        newTab.active = true\n      }\n      this.activeTabIndex = newIndex\n      this.checkStep()\n      this.tryChangeRoute(newTab)\n      this.increaseMaxStep()\n      return true\n    },\n    tryChangeRoute (tab) {\n      if (this.$router && tab.route) {\n        this.$router.push(tab.route)\n      }\n    },\n    checkStep () {\n      if (this.activeTabIndex === this.tabCount - 1) {\n        this.isLastStep = true\n      } else {\n        this.isLastStep = false\n      }\n    },\n    increaseMaxStep () {\n      if (this.activeTabIndex > this.maxStep) {\n        this.maxStep = this.activeTabIndex\n      }\n    },\n    checkRouteChange (route) {\n      let matchingTabIndex = -1\n      let matchingTab = this.tabs.find((tab, index) => {\n        let match = tab.route === route\n        if (match) {\n          matchingTabIndex = index\n        }\n        return match\n      })\n\n      if (matchingTab && !matchingTab.active) {\n        const shouldValidate = matchingTabIndex > this.activeTabIndex\n        this.navigateToTab(matchingTabIndex, shouldValidate)\n      }\n    },\n    getTabs () {\n      return this.$slots.default\n        .filter((comp) => comp.componentOptions)\n    },\n    activateTab (index) {\n      let tab = this.tabs[index]\n      tab.active = true\n      this.tryChangeRoute(tab)\n    },\n    activateTabAndCheckStep (index) {\n      this.activateTab(index)\n      this.checkStep()\n      this.maxStep = this.startIndex\n      this.activeTabIndex = this.startIndex\n    },\n    initializeTabs () {\n      this.tabs = this.getTabs()\n      if (this.tabs.length > 0 && this.startIndex === 0 && !this.tabs[this.activeTabIndex].active) {\n        this.activateTab(this.activeTabIndex)\n      }\n      if (this.startIndex < this.tabs.length && this.startIndex > 0 && !this.tabs[this.startIndex].active) {\n        this.activateTabAndCheckStep(this.startIndex)\n      }\n      if (this.startIndex >= this.tabs.length) {\n        console.warn(`Prop startIndex set to ${this.startIndex} is greater than the number of tabs - ${this.tabs.length}. Make sure that the starting index is less than the number of tabs registered`)\n      }\n    },\n    reinitializeTabs () {\n      let currentTabs = this.getTabs()\n      if (this.tabs.length === 0 || this.tabs.length === currentTabs.length) return\n      this.tabs = currentTabs\n      let oldTabIndex = -1\n      this.tabs.find((tab, index) => {\n        if (tab.active) {\n          oldTabIndex = index\n        }\n        return tab.active\n      })\n      if (oldTabIndex === -1) {\n        oldTabIndex = this.activeTabIndex > 0 ? this.activeTabIndex - 1 : 0\n      }\n\n      this.tabs.forEach((tab) => {\n        tab.active = false\n      })\n      this.activateTab(oldTabIndex)\n      this.maxStep = oldTabIndex\n      this.activeTabIndex = oldTabIndex\n    },\n    renderTabs(){\n      return this.tabs.map((tab, index) => {\n        let {title, icon} = tab.componentOptions.propsData\n        let {active, validationError} = tab\n        return (\n          <li class={{active: active}}>\n            <a onClick={() => this.navigateToTab(index)}>\n              <div class={{\n                checked: this.isChecked(index),\n                square_shape: this.isStepSquare,\n                tab_shape: this.isTabShape,\n                'wizard-icon-circle': true\n              }}\n                   style={[this.isChecked(index) ? this.stepCheckedStyle : {}, validationError ? this.errorStyle : {}]}>\n\n                <transition name={this.transition} mode=\"out-in\">\n                  {active &&\n                  <div\n                    class={{square_shape: this.isStepSquare, tab_shape: this.isTabShape, 'wizard-icon-container': true}}\n                    style={[active ? this.iconActiveStyle : {}, validationError ? this.errorStyle : {}]}>\n                    {icon && <i class={[icon, 'wizard-icon']}></i>}\n                    {!icon && <i class=\"wizard-icon\">{() => this.incrementedIndex(index)} </i>}\n                  </div>\n                  }\n                </transition>\n                {!active && icon && <i class={[icon, 'wizard-icon']}></i>}\n                {!active && icon && <i class=\"wizard-icon\">{() => this.incrementedIndex(index)}</i>}\n\n              </div>\n              <span class={{active: active, has_error: validationError, 'stepTitle': true}}\n                    style={active ? this.stepTitleStyle : {}}>\n              {title}\n            </span>\n            </a>\n          </li>\n        )\n      })\n\n    },\n  },\n  mounted () {\n    this.initializeTabs()\n  },\n\n  render () {\n    let tabs = this.renderTabs()\n    return (\n      <div class=\"vue-form-wizard\">\n        <div class=\"wizard-header\">\n          <slot name=\"title\">\n            <h4 class=\"wizard-title\">{this.title}</h4>\n            <p class=\"category\">{this.subtitle}</p>\n          </slot>\n        </div>\n        <div class=\"wizard-navigation\">\n          <div class=\"wizard-progress-with-circle\">\n            <div class=\"wizard-progress-bar\"\n                 style={this.progressBarStyle}>\n            </div>\n          </div>\n          <ul class=\"wizard-nav wizard-nav-pills\">\n            {tabs}\n          </ul>\n          <div class=\"wizard-tab-content\">\n            {this.$slots.default}\n          </div>\n        </div>\n\n        {!this.hideButtons &&\n        <div class=\"wizard-card-footer clearfix\">\n          {this.displayPrevButton &&\n          <span onClick={this.prevTab} class=\"wizard-footer-left\">\n            <slot name=\"prev\">\n              <button type=\"button\"\n                      class=\"wizard-btn btn-default wizard-btn-wd\" style={this.fillButtonStyle}\n                      disabled={this.loading}>\n              {this.backButtonText}\n            </button>\n          </slot>\n         </span>}\n\n          {this.isLastStep &&\n          <span onClick={this.finish} class=\"wizard-footer-right\">\n             <slot name=\"finish\">\n               <button type=\"button\"\n                       class=\"wizard-btn btn-fill wizard-btn-wd btn-next\"\n                       style={this.fillButtonStyle}>\n                {this.finishButtonText}\n              </button>\n            </slot>\n          </span>}\n\n          {!this.isLastStep &&\n          <span onClick={this.nextTab}\n                class=\"wizard-footer-right\">\n               <slot name=\"next\">\n                 <button type=\"button\"\n                         class=\"wizard-btn btn-fill wizard-btn-wd btn-next\"\n                         style={this.fillButtonStyle}\n                         disabled={this.loading}>\n                  {this.nextButtonText}\n                 </button>\n               </slot>\n             </span>}\n        </div>\n        }\n      </div>\n    )\n  },\n  /***\n   * Used to handle dynamic tab addition from an array since $children is not reactive\n   */\n  watch: {\n    '$route.path': function (newRoute) {\n      this.checkRouteChange(newRoute)\n    }\n  }\n}\n","export default{\n  name: 'tab-content',\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n    /***\n     * Icon name for the upper circle corresponding to the tab\n     * Supports themify icons only for now.\n     */\n    icon: {\n      type: String,\n      default: ''\n    },\n    /***\n     * Function to execute before tab switch. Return value must be boolean\n     * If the return result is false, tab switch is restricted\n     */\n    beforeChange: {\n      type: Function\n    },\n    route: {\n      type: [String, Object]\n    }\n  },\n  data () {\n    return {\n      active: false,\n      validationError: null\n    }\n  },\n  render(){\n    if (this.active) {\n      return (\n        <div class=\"wizard-tab-container\">\n          {this.$slots.default}\n        </div>\n      )\n    }\n  }\n}\n","import FormWizard from './components/FormWizard.js'\nimport TabContent from './components/TabContent.js'\nexport default {\n\n  install (Vue) {\n    Vue.component('form-wizard', FormWizard)\n    Vue.component('tab-content', TabContent)\n  }\n}\n"],"names":["String","Boolean","Number","value","this","tabs","length","activeTabIndex","tabCount","color","progress","errorColor","validationError","shape","percentage","stepPercentage","index","maxStep","validate","cb","changeTab","_this","beforeTabChange","setValidationError","_this2","isLastStep","$emit","_this3","validateOnBack","loading","error","promiseFn","callback","then","setLoading","res","validationResult","executeBeforeChange","catch","oldTab","undefined","beforeChange","tabChangeRes","validateBeforeChange","oldIndex","newIndex","newTab","active","checkStep","tryChangeRoute","increaseMaxStep","tab","$router","route","push","matchingTabIndex","matchingTab","find","match","shouldValidate","navigateToTab","$slots","default","filter","comp","componentOptions","activateTab","startIndex","getTabs","activateTabAndCheckStep","warn","currentTabs","oldTabIndex","forEach","map","propsData","title","icon","h","class","_this6","isChecked","isStepSquare","isTabShape","stepCheckedStyle","errorStyle","name","transition","mode","square_shape","tab_shape","wizard-icon-container","iconActiveStyle","incrementedIndex","has_error","stepTitle","stepTitleStyle","initializeTabs","renderTabs","subtitle","progressBarStyle","hideButtons","displayPrevButton","prevTab","type","style","fillButtonStyle","backButtonText","finish","finishButtonText","nextTab","nextButtonText","newRoute","checkRouteChange","Function","Object","Vue","component","FormWizard","TabContent"],"mappings":"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"}